+ 产生的原因
V8 中，每次垃圾回收时，依次树立对象的引用，将其标记为可到达对象和不可到达对象。

当本该清除的对象，在可到达的对象引用后，未被正确的清除而常驻内存。

+ 产生内存泄漏的情况
    + 全局变量
        ```
        a = 10;
        //未声明对象。

        global.b = 11;
        ```
    + 闭包
    + 事件监听未释放
+ 定位内存泄漏情况
    + 本地可复现，测试环境模拟排查
    + 偶然内存泄漏，一半会与特殊的输入有关系，稳定复现比较耗时，如果不能通过代码的日志定位到特殊输入，那么就需要去生产环境打印内存快照。
    + heapdump 来保存快照
    + devtool 来查看内存快照
    + 打印3个内存快照，内存泄漏之前的内存快照，少量测试后的内存快照，多次测试后的内存快照
+ 避免内存泄漏
    + 工程上：Eslint检测代码非期望的全局变量
    + 代码规范上：避免过于复杂的闭包，清理监听事件
+ 文档
[内存泄漏](https://zhuanlan.zhihu.com/p/25736931)
