+ 产生的原因
V8 中，每次垃圾回收时，依次梳理对象的引用，将其标记为可到达对象和不可到达对象。

当本该清除的对象，在可到达的对象引用后，未被正确的清除而常驻内存。

+ 产生内存泄漏的情况
    + 全局变量
        ```
        a = 10;
        //未声明对象。

        global.b = 11;
        ```
    + 闭包
    + 事件监听未释放
+ 定位内存泄漏情况
    + 本地可复现，测试环境模拟排查
    + 偶然内存泄漏，一半会与特殊的输入有关系，稳定复现比较耗时，如果不能通过代码的日志定位到特殊输入，那么就需要去生产环境打印内存快照。
    + heapdump 来保存快照
    + devtool 来查看内存快照
    + 打印3个内存快照，内存泄漏之前的内存快照，少量测试后的内存快照，多次测试后的内存快照
+ 避免内存泄漏
    + 工程上：Eslint检测代码非期望的全局变量
    + 代码规范上：避免过于复杂的闭包，清理监听事件
+ 内存相关接口
    ```
    import { memoryUsage } from 'process';

    console.log(memoryUsage());
    // 打印:
    // {
    //  rss: 4935680, // 是进程在主内存设备（即总分配内存的子集）中占用的空间量，包括所有 C++ 和 JavaScript 对象和代码。
    //  heapTotal: 1826816, // heapTotal 和 heapUsed 指的是 V8 的内存使用量。
    //  heapUsed: 650472,
    //  external: 49879, // 指的是绑定到 V8 管理的 JavaScript 对象的 C++ 对象的内存使用量。
    //  arrayBuffers: 9386 // 是指为 ArrayBuffer 和 SharedArrayBuffer 分配的内存，包括所有 Node.js Buffer
    // }
    ```
+ 文档
[内存泄漏](https://zhuanlan.zhihu.com/p/25736931)
