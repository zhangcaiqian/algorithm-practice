1. 实时性： 大部分游戏有实时性的要求，期望每一帧的运算不超过限定上额（如16.6ms）。核心部分会采用底层优化的手段。

网络游戏信息同步的实时要求高于大多数软件。

2. 互动性更强：操作和互动会比一些软件复杂，比如说操控角色处理角色在不同状态下的动画处理，角色行走时可能会涉及三维碰撞检测和相关的物理模拟。一些游戏的游戏逻辑错综复杂，要进行不同状态下的动画处理，要考虑每个功能和其他功能之间的影响，由于实时性和互动的复杂性，一般很难做自动但愿测试

3. 技术广度：
+ gameplay: 对游戏的理解，需要大量的推翻，迭代，重做，如何在质量和迭代速度之间找到平衡是一大难点
+ 管线程序
+ 引擎程序

4. 团队配合
游戏制作需要多种专业共同合作，对接策划，美术，音频，测试

客户端写代码的时候，经常需要把一些特殊情况考虑到，比如奔溃，断线重连，切场景，网络波动，时区，连续点击/连续操作，客户端调时间/时区，弱网环境，两个账号登录一个设备(注意本地记录文件的)，一个账号登录多个设备，连续重入(比如异步资源加载，比如请求server，比如UI), 存储到本地的记录性文件防破解破坏等，考虑不到就可能出现奇怪情况。比如，任务系统中在某个任务完成的时候触发一个cutscene，cutscene结束之后需要跳转到另外一个地图。那么如果cutscene播放过程中，奔溃，然后再次登入游戏之后，玩家需要在哪个地图呢？而且因为这个任务已经完成了，这个时机已经过去了，那么这个未完全播放完毕的cutscene是不会被再次播放的，这是策划希望看到的吗？

客户端任务系统，有时候需要使用已完成任务去做一些判断校验，那么就需要保存这些已完成任务的id。之前的做法是每次玩家登入server的时候，server将这些已完成任务列表同步给client，client在内存维护这个列表，但是不记录本地文件。但是后期随着玩家完成的任务越多，这个列表越长，同步的数据量也就会越大。 经过优化的做法是：client本地磁盘也记录这个列表数据，同时client和server各自记录一个该列表数据的版本号version，客户端每次登入游戏的时候，就使用本地的version去请求server，如果server判定两者version一样，则客户端使用记录在本地磁盘的的列表数据。否则server将差异性数据或者全量数据 以及版本号version全部同步给client，client无脑增删改即可。谨记：本地文件一定不能被破解，否则游戏内容中关于任务的完成状态就必然存在问题。

unity中某些检测socket状态的代码 以及 网络消息分发的代码 在update中执行，这就可能会导致同帧问题。 比如 一个server给client踢人的包 先于 server断开socket执行，但是两者在同一帧，然后因为上述逻辑，就会导致踢人的包client无法去处理。需要小心这种基于轮询的状态的逻辑设计。