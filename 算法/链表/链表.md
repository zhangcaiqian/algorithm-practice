> 链表解题思路：
> 1. 快慢指针
> 2. 使用额外的空间记录（堆/栈缓存）


### 基础操作，链表的翻转 [206]
输入：head = [1,2,3,4,5]

输出：[5,4,3,2,1]

![image](https://github.com/zhangcaiqian/algorithm-practice/blob/master/Assets/reverseLink.png)

```
var reverseList = function(head) {
    let cur = null, pre = head;
    while (pre != null)
    {
        let t = pre.next;
        pre.next = cur;
        cur = pre;
        pre = t;
    }
    return cur;
};
```

### 判断链表是否相交[面试题 02.07. 链表相交]
输入：intersectVal = 8, A = [4,1,8,4,5], B = [5,0,1,8,4,5], skipA = 2, skipB = 3

输出：Reference of the node with value = 8

思路：
![image](https://github.com/zhangcaiqian/algorithm-practice/blob/master/Assets/linkIntersection.png)

```
var getIntersectionNode = function(headA, headB) {
    if (headA == null || headB == null)
        return null;
    let pA = headA, pB = headB;
    while (pA != pB)
    {
        pA = pA != null ? pA.next : headB;
        pB = pB != null ? pB.next : headA; 
    }
    return pA;
};
```

### 判断链表是否有环[141] [142]
给定一个链表，判断链表中是否有环。

> 输入：

![image](https://github.com/zhangcaiqian/algorithm-practice/blob/master/Assets/ring.png)

> 输出：true

思路： 【快慢指针】

1. fast指针（n.next.next）和 slow指针（n.next) 交汇时产生一个交点
2. slow重新回到头节点，fast重置为交点处，slow 和 fast 每次移动一位，二者相交即为链表的入环点

证明：
1. 在步骤1中 fast 移动步数 A + 2NR, slow 移动步数为 A + NR，二者的diff 为 NR
2. 在步骤2中，slow重新回到头节点，fast重置为交点处，slow 位置走到 A 时， fast走到 A + NR， 都在入环点位置


判断是否有环：
```
var detectCycle = function(head) {
    if (head == null || head.next == null || head.next.next == null)
        return null;
    let n1 = head.next;
    let n2 = head.next.next;
    while (n1 != n2)
    {
        if (n2.next == null || n2.next.next == null)
            return null;
        n1 = n1.next;
        n2 = n2.next.next;
    }
    n1 = head;
    while (n1 != n2)
    {
        n1 = n1.next;
        n2 = n2.next;
    }
    return n1;
};
```
